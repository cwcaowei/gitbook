#### Young GC、Minor GC、Old GC、Full GC、Mixed GC

  - Young GC、Minor GC

    只回收新生代

  - Old GC

    只回收老年代

  - Mixed GC

    G1收集器独有，回收新生代和部分老年代

  - Full GC

    回收新生代、老年代、元空间、堆外内存

#### Young GC的触发条件

- Eden内存不够（TLAB不够或者共享区不够）

- 有些垃圾收集器比如Parallel Scavenge在Full GC前会先执行一次Young GC

#### Full GC的触发条件

- 新生代晋升到老年代的对象大小大于老年代的剩余空间

- 老年代的空间使用率超过某个阈值

- 大对象直接进老年代的时候老年代空间不足

- 元空间不足

- System.gc()、jmap -dump

#### 垃圾回收的判断方法

- 引用计数法

  每个对象都有一个被引用计数器，被引用一次计数器加1，引用被置空时减1，最终被引用计数器的值为0的即是可以被回收的对象。但是这种方法无法处理循环引用的场景，如下objA，objB两个对象内部分别有一个变量a指向对方，通过objA = null和objB = null释放强引用后，堆中的这两个对象实际已无法再被访问到，但它们的被引用计数器是1，还不是0，无法被回收。

  ![](/assets/jvm/judge.png)

- GC Roots

  将由栈内存或方法区引用的对象作为GC Roots去构建引用链，如果能找到这个对象则说明这个对象能够访问，其内存不能被回收，反之通过这些引用链找不到这个对象则说明已经是弃用的对象了，其内存是应该被回收的。上面的互相循环引用的例子就可以解决了，因为这个问题里面虽然其被引用计数器的值不为0，但是已经没有GC Roots能够找到这些内存了，这个问题里的GC Roots是栈内存里的objA和objB，这两个栈内存里的引用被置空，因此引用链里没办法再找到堆内存里的对象了。GC roots一般有以下几种：

  - 线程栈的本地变量，静态变量

  - 本地方法栈的变量

  - 由AppClassLoader/BootClassLoader加载的类对象，这些对象不会被回收。其它的ClassLoader加载的类对象不一定是GC root，除非这个类对象恰好是其它形式的GC root;

  - 激活状态的线程

  - JNI中的全局变量或者局部变量和参数引用的对象，可能在JNI中定义的，也可能在虚拟机中定义

  - 用于保证同步的对象，例如wait()，notify()中使用的对象、锁等

#### 对象进入老年代的条件

- Survivor区里的对象中相同年龄的对象的大小达到Survivor区的一半，那么大于等于该年龄的对象将会进入老年代

- 年龄达到MaxTenuringThreshold的对象

- 大对象，可通过-XX:PretenureSizeThreshold设置，只对Serial和ParNew两个收集器有效

#### 空间分配担保机制

在发生Minor GC之前，JVM会检查老年代最大可用的连续空间是否大于新生代目前所有对象占用的总空间，如果大于，则此次Minor GC是安全的，如果小于，JVM就需要判断HandlePromotionFailure是否允许空间分配担保，如果允许，JVM继续检查老年代最大的可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则正常进行一次Minor GC（尽管有风险，因为判断的是平均大小，有可能这次的晋升对象比平均值大很多），如果小于，或者HandlePromotionFailure设置不允许空间分配担保，就要进行一次Full GC。  来了一个对象，eden区空间不足，survivor区也放不下，把eden区的对象移到老年代，这样eden区就有空间放这个对象了

![](/assets/jvm/guarantee.png)

#### 方法区回收的判断

- 类的所有实例都已被回收

- 加载该类的ClassLoader已被回收（只有自定义的类加载器才能被回收）

- 类对应的Java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法

#### Minor GC的过程

- Eden区空间不足触发Minor GC，存活对象被移至某个Survivor区

- Eden区又空间不足触发Minor GC，Eden区和Survivor区的存活对象移至另一个空着的Survivor区，且对象的分代年龄+1

- 之后的Minor GC就是两个Survivor区轮着放对象

#### 栈上分配与逃逸分析

- 逃逸分析与栈上分配

  分析对象作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，也可能作为返回值，但如果它只在方法内部有效，这样的对象其实可以将其分配在栈内存里，让其在方法结束时跟随栈内存一起被回收掉。栈上分配依赖于逃逸分析和标量替换。

  ```java
  private static void test() {
      // user的作用域只在方法内
      User user = new User();
      user.setA("123");
  }
  ```

- 标量替换

  通过逃逸分析确定对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。标量即不可被进一步分解的量，比如基本数据类型。
