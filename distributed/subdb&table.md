#### 为什么要分库分表

- 单表数据量过大时会影响性能

- 进行表结构操作（如字段，索引）时会锁表，且极其耗时

- 防止未经优化的SQL触发全表扫描，控制风险

#### 分库分表的方式

- 垂直切分

  - 单库

    表字段太多，将表结构拆分开，比如一张用户表包含姓名、身份证、手机号等基本信息，又包含入职时间、职级、上级领导等公司层面信息，就可以拆分成两张表。

  - 多库

    表太多，将表拆分到不同的数据库，比如一个库存用户相关的表，一个库存订单相关的表。

- 水平切分

  - 单库

    表数据太多，将表数据拆分到不同表中，比如每个月产生3000万数据，按月份每个月建一张新表t_order_202101、t_order_202102。。。，这种方式可以解决单表数据量过大的性能问题，但不能解决单机存储的瓶颈问题。

  - 多库

    表数据太多，将表数据拆分到不同数据库存储，各个库中的该表结构是一致的。

#### 带来的问题及解决方案

- 跨库的关联查询

  无法使用join或者多表的关联查询。可以通过如下几种方式解决：

  - 字段冗余

    把想要关联查询的字段比如用户姓名在订单表中也存一份，一般订单表只存用户ID，这种方式其实违反了第三范式。

    - 第一范式

      字段不可再拆分，不能是一些信息的集合，比如联系方式这个字段包含了手机号、邮箱、地址，就违反了第一范式。

    - 第二范式

      表的每行可以被唯一的区分，换句话说，字段要完全依赖于主键，比如主键是两个字段订单ID和商品ID联合的，那么商品名称这个字段就只是依赖于主键的一部分（商品ID），就不应该存在该表中。

    - 第三范式

      数据不能存在传递关系，换句话说，表不要存不相关的字段，比如订单表只应该有用户ID，不应该有用户姓名。

  - 广播表

    所有库都存一份，并通过一些手段保证数据的同步。

  - 应用层的组装

    在各个库查询出一定的数据，在应用中重新整合成想要的结果。

- 排序、分页、函数的计算

  order by、limit、max/min/sum/count等函数，都需要先在每个库执行一遍，然后将结果汇总后再进行一遍计算才能得到准确结果。

- 分布式ID

  如果主键是自增类型，会出现ID重复。可以通过UUID或者雪花算法来解决。

- 分布式事务

  另起一篇，单独详述。
