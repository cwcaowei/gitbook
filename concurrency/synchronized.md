#### synchronized的三种应用方式

- 修饰普通方法，锁是当前实例对象

- 修饰静态方法 锁是当前类的Class对象

- 修饰方法体中的代码块（不能修饰类里面的构造代码块或静态代码块），锁是synchronized后面括号里指定的对象

#### synchronized的字节码指令

通过javap -v来查看对应代码的字节码指令，对于同步代码块的实现使用了monitorenter和monitorexit指令，它们隐式的执行了Lock和UnLock操作，用于提供原子性保证。monitorenter指令插入到同步代码块开始的位置，monitorexit指令插入到同步代码块结束位置和异常处，jvm需要保证每个monitorenter都有一个monitorexit对应。

同步方法是依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。任何对象都有且仅有一个监视器（monitor）与之关联，无论采用三种方式中的哪种，其本质是对一个对象的监视器进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到锁对应对象的监视器。

![](/assets/concurrency/monitor.png)

任意线程对Object（锁对象）的访问，线程执行到monitorenter指令时，首先要获得Object的监视器（获取锁）。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当持有monitor（获得了锁）的线程执行monitorexit，释放monitor的所有权（释放锁），则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。

#### synchronized的锁的原理

- 对象头

  在Hotspot虚拟机中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。

  如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit。

  ![](/assets/concurrency/objectHeader.png)

  32位JVM的Mark Word的默认存储结构如下：

  ![](/assets/concurrency/markword32.png)

  在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化，Mark Word可能变化为存储以下数据：

  ![](/assets/concurrency/markwordDetail32.png)

  在64位JVM下，Mark Word是64bit大小的，其存储结构下：

  ![](/assets/concurrency/markword64.png)

  如下，每一行是一个状态，每个状态下Mark Word存储内容不一样，无其他线程竞争的情况下，由normal object变为biased object。

  ![](/assets/concurrency/markwordDetail32&64.png)

- 锁升级

  - 自旋锁

    自旋锁就是让不满足条件的线程等待一段时间，而不是立即挂起。看持有锁的线程是否能够很快释放锁。怎么自旋呢？其实就是一段没有任何意义的循环。
    虽然它通过占用处理器的时间来避免线程切换带来的开销，但是如果持有锁的线程不能很快释放锁，那么自旋的线程就会浪费处理器的资源，因为它不会做任何有意义的工作。所以，自旋等待的时间或者次数是有一个限度的，如果自旋超过了定义的时间仍然没有获取到锁，则该线程会被挂起，这个时间是JVM自己管理的，不需要我们设置。

  - 偏向锁

    在大多数情况下，锁不仅仅不存在多线程的竞争，而且总是由同一个线程多次获得，在这个背景下就设计了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

    偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

    ![](/assets/concurrency/biasedlock.png)

  - 轻量级锁

    如果偏向锁被关闭（一般实际都是关闭的）或者当前偏向锁已经被其他线程获取，那么这个时候如果有线程去抢占同步锁时，锁会升级到轻量级锁。

    - 加锁

    线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

    - 解锁

    轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

    ![](/assets/concurrency/light&heavyweightLock.png)

  - 重量级锁

    重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。
