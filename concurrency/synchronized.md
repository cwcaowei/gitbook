#### synchronized的三种应用方式

- 修饰普通方法，锁是当前实例对象

- 修饰静态方法 锁是当前类的Class对象

- 修饰方法体中的代码块（不能修饰类里面的构造代码块或静态代码块），锁是synchronized后面括号里指定的对象

#### synchronized的字节码指令

通过javap -v来查看对应代码的字节码指令，

对于同步方法，JVM采用ACC_SYNCHRONIZED标记符来实现同步，同步方法的常量池中会有一个ACC_SYNCHRONIZED标志，当某个线程要访问某个方法的时候，会检查是否有ACC_SYNCHRONIZED标志，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁，这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。

对于同步代码块则使用了monitorenter和monitorexit指令，monitorenter指令插入到同步代码块开始的位置，monitorexit指令插入到同步代码块结束位置和异常处，编译器需要确保方法中调用过的每条monitorenter指令都要执行对应的monitorexit指令。为了保证在方法异常时，monitorenter和monitorexit指令也能正常配对执行，编译器会自动产生一个异常处理器，它的目的就是用来执行异常的monitorexit指令。所以会有两个monitorexit指令，多的那个就是异常结束时，被执行用来释放monitor的。

同步方法是依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。任何对象都有且仅有一个监视器（monitor）与之关联，无论采用三种方式中的哪种，其本质是对一个对象的监视器进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到锁对应对象的监视器。

![](/assets/concurrency/monitor.png)

任意线程对Object（锁对象）的访问，线程执行到monitorenter指令时，首先要获得Object的监视器（获取锁）。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当持有monitor（获得了锁）的线程执行monitorexit，释放monitor的所有权（释放锁），则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。

#### synchronized的锁的原理

- 对象

  在Hotspot虚拟机中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。

  ![](/assets/concurrency/object.png)

  - 对象头

    包括Mark Word、Klass Pointer和数组长度（如果对象是数组的话）三个部分，Klass Pointer是Class对象的类型指针，Jdk1.8默认开启指针压缩后为4字节，关闭指针压缩（-XX:-UseCompressedOops）后，长度为8字节。其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址。

  - 对象实际数据

    包括对象的所有成员变量，大小由各个成员变量决定，比如：byte占1个字节8比特位、int占4个字节32比特位。

  - 对齐

    最后这段空间补全并非必须，仅仅为了起到占位符的作用。由于HotSpot虚拟机的内存管理系统要求对象起始地址必须是8字节的整数倍，所以对象头正好是8字节的倍数。因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

- 对象头

  如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit。

  ![](/assets/concurrency/objectHeader.png)

  32位JVM的Mark Word的默认存储结构如下：

  ![](/assets/concurrency/markword32.png)

  在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化，Mark Word可能变化为存储以下数据：

  ![](/assets/concurrency/markwordDetail32.png)

  在64位JVM下，Mark Word是64bit大小的，其存储结构下：

  ![](/assets/concurrency/markword64.png)

  如下，每一行是一个状态，每个状态下Mark Word存储内容不一样，无其他线程竞争的情况下，由normal object变为biased object。

  ![](/assets/concurrency/markwordDetail32&64.png)

- 锁升级

  ![](/assets/concurrency/lockPro.png)

  - 自旋锁

    在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。

    而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销，这就是自旋锁。

    自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。

  - 适应性自旋锁

    自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。

  - 偏向锁

    在大多数情况下，锁不仅仅不存在多线程的竞争，而且总是由同一个线程多次获得，在这个背景下就设计了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

    偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

    ![](/assets/concurrency/biasedlock.png)

  - 轻量级锁

    如果偏向锁被关闭（一般实际都是关闭的）或者当前偏向锁已经被其他线程获取，那么这个时候如果有线程通过自旋去抢占同步锁时，锁会升级到轻量级锁。

    - 加锁

    线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针,并将锁记录里的owner指针指向对象的Mark Word。如果成功，当前线程获得锁，如果失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

    - 解锁

    轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

    ![](/assets/concurrency/light&heavyweightLock.png)

  - 重量级锁

    重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。

  - 锁对比

    偏向锁、轻量级锁都是乐观锁，不会阻塞，重量级锁是悲观锁，会阻塞。

    ![](/assets/concurrency/lockCompare.png)


- 锁消除

  锁消除即删除不必要的加锁操作。虚拟机即时编辑器在运行时，对一些“代码上要求同步，但是被检测到不可能存在共享数据竞争”的锁进行消除。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。

  ```java
  public class SynchronizedTest {

      public static void main(String[] args) {
          SynchronizedTest test = new SynchronizedTest();

          for (int i = 0; i < 100000000; i++) {
              test.append("abc", "def");
          }
      }

      public void append(String str1, String str2) {
          StringBuffer sb = new StringBuffer();
          sb.append(str1).append(str2);
      }

  }
  ```

  虽然StringBuffer的append是一个同步方法，但是这段程序中的StringBuffer属于一个局部变量，并且不会从该方法中逃逸出去（即sb的引用没有传递到该方法外，不可能被其他线程拿到该引用），所以其实这过程是线程安全的，可以将锁消除。

- 锁粗化

  如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

  ```java
  public class StringBufferTest {
      StringBuffer stringBuffer = new StringBuffer();

      public void append(){
          stringBuffer.append("a");
          stringBuffer.append("b");
          stringBuffer.append("c");
      }
  }
  ```

  这里每次调用stringBuffer.append()都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append时进行加锁，最后一次append结束后进行解锁。
