#### 原理

- wait方法

  调用的前提是持有监视器锁，若持有锁，会让当前线程变成等待状态，进入等待队列并且释放锁。

- notify/notifyAll方法

  如果是notify，会选择从等待队列中唤醒任意一个线程，但是并不会立马唤醒线程，因为当前的线程仍然持有这把锁，处于等待状态的线程无法获得锁，必须要等当前的线程执行完monitorexit指令即锁被释放以后，此时处于等待队列中的线程就可以开始竞争锁了。

  ![](/assets/concurrency/wait&notify.png)

#### wait和notify为什么需要在synchronized里面

wait的语义有两个，一个是释放当前的对象锁，另一个是使得当前线程进入阻塞队列，而这些操作都和监视器相关，所以wait必须要获得一个监视器锁。
notify也是一样，它是唤醒一个线程，首先得知道它在哪里，所以就必须要找到这个对象，获取到这个对象的锁，然后到这个对象的等待队列中去唤醒一个线程。
